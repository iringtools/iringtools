/*
 * File: Scripts/AM/view/mapping/MappingTree.js
 *
 * This file was generated by Sencha Architect version 2.1.0.
 * http://www.sencha.com/products/architect/
 *
 * This file requires use of the Ext JS 4.1.x library, under independent license.
 * License of Sencha Architect does not include license for Ext JS 4.1.x. For more
 * details see http://www.sencha.com/license or contact license@sencha.com.
 *
 * This file will be auto-generated each and everytime you save your project.
 *
 * Do NOT hand edit this file.
 */

Ext.define('AM.view.mapping.MappingTree', {
  extend: 'Ext.tree.Panel',
  alias: 'widget.mappingtree',

  requires: [
    'AM.view.override.mapping.MappingTree'
  ],

  border: true,
  stateful: true,
  store: 'MappingStore',
  rootVisible: false,

  initComponent: function() {
    var me = this;

    Ext.applyIf(me, {
      stateEvents: [
        'itemcollapse',
        'itemexpand'
      ],
      viewConfig: {
        plugins: [
          Ext.create('Ext.tree.plugin.TreeViewDragDrop', {
            ptype: 'treeviewdragdrop',
            ddGroup: 'refdataGroup',
            enableDrag: false
          })
        ],
        listeners: {
          beforedrop: {
            fn: me.onBeforeNodeDrop,
            scope: me
          }
        }
      },
      dockedItems: [
        {
          xtype: 'toolbar',
          dock: 'top',
          items: [
            {
              xtype: 'button',
              handler: function(button, event) {
                var tree = button.up('toolbar').up('panel');
                var node = tree.getRootNode();
                tree.onReload(node);
              },
              icon: 'Content/img/16x16/view-refresh.png',
              text: 'Reload Tree'
            },
            {
              xtype: 'button',
              handler: function(button, event) {
                me.onSave();
              },
              icon: 'Content/img/16x16/document-save.png',
              text: 'Save'
            }
          ]
        }
      ],
      listeners: {
        itemcontextmenu: {
          fn: me.showContextMenu,
          scope: me
        },
        beforeload: {
          fn: me.onBeforeLoad,
          scope: me
        }
      },
      selModel: Ext.create('Ext.selection.RowModel', {

      })
    });

    me.callParent(arguments);
  },

  onBeforeNodeDrop: function(node, data, overModel, dropPosition, dropFunction, options) {
    var me = this;
    var pan = me.up('mappingpanel');
    me.getParentClass(overModel);
    var nodetype, thistype, icn, txt, templateId, rec, parentId, context;
    var graphName = pan.graphName;
    if (overModel.data.type == 'RoleMapNode') {
      reference = data.records[0].data.record.Uri;
      label = data.records[0].data.record.Label;
      roleId = overModel.data.record.id;
      roleName = overModel.data.record.name;
      rec = data.records[0].data.record;
      txt = data.records[0].data.record.Label;
      parentId = me.parentClass;
      f = false;
      var index = overModel.parentNode.parentNode.indexOf(overModel.parentNode);
      this.getEl().mask('Loading...');
      Ext.Ajax.request({
        url: 'mapping/mapreference',
        method: 'POST',
        params: {
          reference: reference,
          classId: parentId,
          label: label,
          roleId: roleId,
          roleName: roleName,
          contextName: pan.contextName,
          endpoint: pan.endpoint,
          index: index,
          graphName: graphName,
          baseUrl: pan.baseUrl
        },
        success: function (result, request) {
          tree.getEl().unmask();
          me.onReload();
        },
        failure: function (result, request) {
          //don't drop it
          return false;
        }
      });
    }
    if (data.records[0].data.type == 'TemplateNode') {
      ntype = overModel.data.type;
      parentid = overModel.data.identifier;
      thistype = data.records[0].data.type;
      icn = 'Content/img/template-map.png';
      txt = data.records[0].data.record.Label;
      templateId = data.records[0].data.identifier;
      rec = data.records[0].data.record;
      //context = overModel.data.id + '/' + txt;
      lf = false;
      me.getEl().mask('Loading...');
      Ext.Ajax.request({
        url: 'mapping/addtemplatemap',
        method: 'POST',
        params: {
          contextName: pan.contextName,
          endpoint: pan.endpoint,
          baseUrl: pan.baseUrl,
          nodetype: thistype,
          parentType: ntype,
          parentId: parentid,
          id: templateId,
          graphName: graphName
        },
        success: function (result, request) {
          me.getEl().unmask();
          me.onReload();
          return false;
        },
        failure: function (result, request) {
          return false;
        }
      });
    }
    else {
      return false;
    }
    return false;

  },

  showContextMenu: function(tablepanel, record, item, index, e, options) {
    var me = this;
    e.stopEvent();
    var obj = record.store.getAt(index).data;

    if (obj.type == "TemplateMapNode") {
      var templatemapMenu = Ext.widget('templatemapmenu');
      templatemapMenu.showAt(e.getXY());
    } else if (obj.type == "RoleMapNode") {
      var rolemapMenu = Ext.widget('rolemapmenu');
      rolemapMenu.showAt(e.getXY());
    } else if (obj.type == "ClassMapNode") {
      var classmapMenu = Ext.widget('classmapmenu');
      classmapMenu.showAt(e.getXY());
    }
  },

  onBeforeLoad: function(store, operation, options) {
    store.proxy.extraParams.type = operation.node.data.type;
    if (store.proxy.extraParams !== undefined) {
      store.proxy.extraParams.id = operation.node.data.id;
    }
  },

  applyState: function(state) {
    var me = this;
    var nodes = state.expandedNodes || [],
    len = nodes.length;
    me.collapseAll();
    Ext.each(nodes, function (path) {
      me.expandPath(path, 'text');
    });
    me.callParent(arguments);
  },

  getState: function() {
    var me = this;
    var nodes = [], state = me.callParent();
    me.getRootNode().eachChild(function (child) {
      // function to store state of tree recursively 
      var storeTreeState = function (node, expandedNodes) {
        if (node.isExpanded() && node.childNodes.length > 0) {
          expandedNodes.push(node.getPath('text'));

          node.eachChild(function (child) {
            storeTreeState(child, expandedNodes);
          });
        }
      };
      storeTreeState(child, nodes);
    });
    Ext.apply(state, {
      expandedNodes: nodes
    });
    return state;
  },

  onReload: function() {
    var me = this;
    var graphName = me.up('mappingpanel').graphName;
    var path, graphNode;
    var node = me.getSelectedNode();
    var store = me.store;
    var root = me.getRootNode();
    root.eachChild(function(child) {
      if(child.data.text == graphName)
      graphNode = child;
    });

    if (node) {
      path = node.getPath('text');
      store.load(node);
      if(node.isExpanded())
      node.collapse();
    }

    if(path) {
      // alert(path);
      me.expandPath(path, 'text');
      me.getSelectionModel().select(node);
    }
  },

  onSave: function() {
    var me = this;
    var mapPanel = me.isContained;
    Ext.Ajax.request({
      url: 'mapping/updateMapping',
      method: 'POST',
      params: {
        contextName: mapPanel.context,
        endpoint: mapPanel.endpoint,
        baseUrl: mapPanel.baseUrl
      },
      success: function (result, request) {
        me.onReload();
      },
      failure: function (result, request) {
        return false;
      }
    });
  },

  getParentClass: function(n) {
    if (n.parentNode !== null && n.parentNode !== undefined) {
      if ((n.parentNode.data.type == 'ClassMapNode' || 
      n.parentNode.data.type == 'GraphMapNode') && 
      n.parentNode.data.identifier !== undefined) {
        this.parentClass = n.parentNode.data.identifier;
        return this.parentClass;
      }
      else {
        this.getParentClass(n.parentNode);
      }
    }
  },

  getSelectedNode: function() {
    var me = this;
    var selected = me.getSelectionModel().getSelection();
    return selected[0];
  }

});